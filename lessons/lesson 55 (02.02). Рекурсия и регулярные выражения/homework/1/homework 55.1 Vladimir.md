Написать функцию is_balanced(string), которая проверяет, сбалансированы ли скобки в строке. Строка считается сбалансированной, если:

Каждая открывающая скобка имеет соответствующую закрывающую.
Скобки открываются и закрываются в правильном порядке.
Скобки бывают следующих типов: (), {}, [].

Используйте рекурсию для реализации алгоритма. Строка состоит только из скобок.

## Указания

Базовый случай:
Если строка пустая, она считается сбалансированной.
Если строка содержит один символ или не начинается с открывающей скобки, она не сбалансирована.

Рекурсивный случай:
Найдите ближайшую правильную пару скобок (например, () или {}).
Удалите её из строки и вызовите функцию для оставшейся части строки.

---

## Ключевая идея решения (интуитивно)

Если строка действительно сбалансирована, то где-то внутри **обязательно** есть хотя бы одна корректная соседняя пара:

- `()`
- `{}`
- `[]`

Почему это работает:

- **В любой правильной скобочной последовательности существует хотя бы одна пара, которая стоит рядом.** Это самая “внутренняя” пара.
- Если такую пару удалить, оставшаяся строка тоже должна быть сбалансированной.
- Если корректных соседних пар больше нет, но строка не пустая, значит порядок нарушен и строка не сбалансирована.

Этот подход специально сделан под рекурсию: каждый рекурсивный шаг уменьшает строку, пока она не станет пустой (успех) или не перестанет уменьшаться (провал).

---

## Псевдокод


```
ФУНКЦИЯ is_balanced(S)
    ЕСЛИ S пустая
        ВЕРНУТЬ ИСТИНА

    НАЙДЕНА_ПАРА = ЛОЖЬ

    ДЛЯ КАЖДОЙ ПАРЫ P ИЗ МНОЖЕСТВА {"()", "{}", "[]"}
        ЕСЛИ S содержит P как подстроку
            НАЙДЕНА_ПАРА = ИСТИНА

    ЕСЛИ НАЙДЕНА_ПАРА = ИСТИНА
        ДЛЯ КАЖДОЙ ПАРЫ P ИЗ МНОЖЕСТВА {"()", "{}", "[]"}
            ПОКА S содержит P как подстроку
                УДАЛИТЬ ОДНО ВХОЖДЕНИЕ P ИЗ S

        ВЕРНУТЬ is_balanced(S)

    ИНАЧЕ
        ВЕРНУТЬ ЛОЖЬ
КОНЕЦ ФУНКЦИИ
```

---

## Детальный разбор алгоритма

### 1) Что мы считаем “успехом”

- Если строка стала пустой, значит мы смогли “снять” все пары. Это возможно только если порядок был корректный.

### 2) Что мы делаем на каждом шаге рекурсии

- Проверяем, есть ли в строке хотя бы одна соседняя правильная пара из списка `()`, `{}`, `[]`.
- Если есть, удаляем все такие пары (в любом порядке, пока они встречаются).
- Рекурсивно запускаем проверку для укороченной строки.

### 3) Когда возвращаем `False`

- Если строка не пустая, но **ни одной** соседней корректной пары не осталось.

Примеры, где это происходит:

- `)(` (порядок сломан)
- `([)]` (перекрестное закрытие разных типов)

### 4) Почему рекурсия гарантированно заканчивается

- Каждый раз, когда мы нашли хотя бы одну пару, длина строки уменьшается минимум на 2 символа.
- Строка конечна. Значит, после конечного числа шагов мы либо дойдем до пустой строки, либо упрёмся в ситуацию без пар.

### 5) Примеры прохождения

#### Пример A: `([]{})`

- Шаг 1: есть `[]` и `{}`. Удаляем их. Получаем `()`
- Шаг 2: есть `()`. Удаляем. Получаем пустую строку
- Базовый случай. Ответ: `True`

#### Пример B: `([)]`

- Шаг 1: в строке нет `()`, нет `[]`, нет `{}` как соседних подстрок
- Строка не пустая. Ответ: `False`
