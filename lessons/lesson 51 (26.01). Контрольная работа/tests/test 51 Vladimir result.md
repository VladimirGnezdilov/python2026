Вопросы с выбором варианта: 72/100%  
Вопросы с текстовыми ответами: 0/0%  
# Вопрос 1. Тема 1: Условные конструкции и циклы в Python
  
Какие значения в Python считаются ложными (falsy)?
  
Варианты ответов:
1) Только значение 0
2) ✅ Значения, приводимые к False
3) Только отрицательные числа
4) Только пустые строки
5) Только None
  
### ИИ анализ  
Выбран правильный вариант. В Python "falsy" значения — это те, которые при приведении к булевому типу дают `False`.  К ним относятся `False`, `None`, нулевые числовые значения, пустые коллекции (список, строка, кортеж, словарь) и некоторые другие.  Ваш ответ показывает понимание этого общего принципа, а не конкретных примеров.  

  
# Вопрос 2. Тема 1: Условные конструкции и циклы в Python
  
Зачем используется `elif`?
  
Варианты ответов:
1) Для вывода текста
2) Для создания функции
3) Для обработки исключений
4) Для остановки цикла
5) ✅ Для добавления нового условия
  
### ИИ анализ  
Вы правильно определили назначение `elif`.  Это ключевое слово используется в цепочке условных операторов `if-elif-else` для проверки дополнительных условий, если предыдущее условие (`if` или предыдущий `elif`) оказалось ложным.  Это позволяет создавать разветвленную логику без необходимости вкладывать множество отдельных `if`.  

  
# Вопрос 3. Тема 1: Условные конструкции и циклы в Python
  
В каком случае удобнее использовать `for`?
  
Варианты ответов:
1) Когда нужно повторять бесконечно
2) Когда нет итератора
3) Когда условие меняется случайно
4) ✅ Когда известен набор значений
5) Когда нужно ждать событие
  
### ИИ анализ  
Вы верно выбрали вариант.  Цикл `for` идеально подходит для итерации по заранее известной или определяемой последовательности (например, списку, строке, диапазону `range`, ключам словаря).  Он автоматически перебирает элементы, избавляя программиста от необходимости вручную управлять индексом или условием остановки.  

  
# Вопрос 4. Тема 1: Условные конструкции и циклы в Python
  
В каком случае удобнее использовать `while`?
  
Варианты ответов:
1) Когда есть range
2) ✅ Когда условие важно каждый раз
3) Когда есть список значений
4) Когда нужна сортировка
5) Когда нужен словарь
  
### ИИ анализ  
Правильный ответ выбран.  Цикл `while` используется, когда количество повторений заранее неизвестно и выполнение зависит от условия, которое проверяется перед каждой итерацией.  Он продолжает работу, пока условие истинно, что делает его подходящим для обработки событий, чтения данных до определенного маркера или реализации бесконечных циклов с прерыванием `break`.  

  
# Вопрос 5. Тема 1: Условные конструкции и циклы в Python
  
Что делает `break`?
  
Варианты ответов:
1) Пропускает итерацию
2) ✅ Полностью прерывает цикл
3) Останавливает программу
4) Переходит в else блока
5) Перезапускает цикл
  
### ИИ анализ  
Вы абсолютно правы.  Оператор `break` используется для немедленного и полного выхода из цикла (`for` или `while`), в теле которого он находится.  Управление передается следующей инструкции после цикла.  Это полезно для досрочного завершения цикла при выполнении какого-либо условия (например, нахождения искомого элемента).  

  
# Вопрос 6. Тема 1: Условные конструкции и циклы в Python
  
Что делает `continue`?
  
Варианты ответов:
1) Возвращает значение
2) Переходит к else блока
3) ✅ Пропускает текущую итерацию
4) Завершает программу
5) Завершает цикл полностью
  
### ИИ анализ  
Вы правильно поняли функцию `continue`.  Этот оператор прерывает выполнение текущей итерации цикла и немедленно переходит к проверке условия (в `while`) или к следующему элементу (в `for`), начиная новую итерацию.  Он используется, когда нужно пропустить часть кода в цикле для определенных случаев, не выходя из самого цикла.  

  
# Вопрос 7. Тема 1: Условные конструкции и циклы в Python
  
Когда выполняется `else` в конструкции `for ... else`?
  
Варианты ответов:
1) Всегда после первого шага
2) ❌ Только если цикл пустой
3) Только при ошибке
4) Только если был `continue`
5) Если цикл завершился без `break`
  
### ИИ анализ  
Выбран неверный вариант.  Блок `else` в конструкции `for-else` выполняется только в том случае, если цикл завершился естественным образом, то есть не был прерван оператором `break`.  Это полезно для поиска элементов: код в `else` выполняется, если искомый элемент не был найден.  Блок `else` выполняется даже для пустого итерируемого объекта.  

  
# Вопрос 8. Тема 1: Условные конструкции и циклы в Python
  
Как записать тернарное выражение (условие в одну строку) в Python?
  
Варианты ответов:
1) `a ? b : c`
2) `b unless a else c`
3) `if (a) {b} else {c}`
4) `if a: b else: c`
5) `b if a else c`
  
### ИИ анализ  
Выбран правильный синтаксис.  Тернарный условный оператор в Python имеет форму `[значение_if_true] if [условие] else [значение_if_false]`.  Он позволяет компактно присваивать значение переменной в зависимости от условия.  Важно помнить порядок: сначала результат для истинного условия, затем само условие, и наконец результат для ложного.  

  
# Вопрос 9. Тема 1: Условные конструкции и циклы в Python
  
Что такое итерация в цикле `for`?
  
Варианты ответов:
1) Объявление переменной
2) Завершение цикла
3) Создание списка
4) ✅ Один проход тела цикла
5) Запуск программы
  
### ИИ анализ  
Вы дали точное определение.  Итерация — это однократное выполнение тела цикла для текущего элемента из итерируемой последовательности.  Каждый раз, когда цикл `for` берет следующий элемент и выполняет для него код внутри цикла, происходит одна итерация.  Количество итераций обычно равно количеству элементов в последовательности.  

  
# Вопрос 10. Тема 1: Условные конструкции и циклы в Python
  
Как остановить цикл `while True` изнутри цикла?
  
Варианты ответов:
1) Использовать `pass`
2) Использовать `continue`
3) ✅ Использовать `break`
4) Использовать `print`
5) Использовать `elif`
  
### ИИ анализ  
Верный ответ.  Цикл `while True` является бесконечным, так как его условие всегда истинно.  Единственный способ корректно выйти из такого цикла — использовать оператор `break` внутри его тела, когда будет выполнено определенное условие.  `continue` в этом случае лишь перезапустит текущую итерацию, но не остановит цикл.  

  
# Вопрос 11. Тема 2: Коллекции уровня «джун+». списки, срезы, вложенные структуры
  
Чем отличается `list.append(x)` от `list.extend(iterable)`?
  
Варианты ответов:
1) Разницы нет
2) `append` добавляет все элементы
3) `extend` добавляет один элемент
4) ✅ `append` добавляет один элемент
5) `extend` удаляет элементы
  
### ИИ анализ  
Вы правильно уловили разницу.  Метод `append(x)` добавляет свой аргумент `x` как один элемент в конец списка, даже если `x` является списком (тогда вложенный список станет одним элементом).  Метод `extend(iterable)` добавляет все элементы из итерируемого объекта `iterable` по отдельности, расширяя исходный список.  

  
# Вопрос 12. Тема 2: Коллекции уровня «джун+». списки, срезы, вложенные структуры
  
Как обратиться к последнему элементу списка по индексу?
  
Варианты ответов:
1) `a[last]`
2) `a[end]`
3) `a[1]`
4) ✅ `a[-1]`
5) `a[0]`
  
### ИИ анализ  
Вы выбрали правильный вариант.  В Python поддерживается отрицательная индексация.  Индекс `-1` ссылается на последний элемент, `-2` — на предпоследний и так далее.  Это очень удобный и лаконичный способ доступа к элементам с конца коллекции без необходимости знать её точную длину.  

  
# Вопрос 13. Тема 2: Коллекции уровня «джун+». списки, срезы, вложенные структуры
  
Что означает `start` в срезе `[start:stop:step]`?
  
Варианты ответов:
1) Шаг среза
2) Индекс конца среза
3) ✅ Индекс начала среза
4) Тип результата
5) Количество элементов
  
### ИИ анализ  
Верно.  Параметр `start` в срезе задаёт индекс элемента, с которого начинается извлечение.  Этот элемент включается в результат.  Если `start` не указан, срез начинается с начала последовательности (индекс 0).  Значение может быть отрицательным, отсчитывая позицию с конца.  

  
# Вопрос 14. Тема 2: Коллекции уровня «джун+». списки, срезы, вложенные структуры
  
Что означает `stop` в срезе `[start:stop:step]`?
  
Варианты ответов:
1) Индекс начала
2) Размер списка
3) Шаг
4) Значение элемента
5) ✅ Индекс конца, не включая
  
### ИИ анализ  
Правильный ответ.  Параметр `stop` определяет индекс, *до которого* (но не включая его) выполняется срез.  Элемент с индексом `stop` не попадает в результат.  Если `stop` не указан, срез продолжается до конца последовательности.  Это поведение аналогично функции `range(start, stop)`.  

  
# Вопрос 15. Тема 2: Коллекции уровня «джун+». списки, срезы, вложенные структуры
  
Что означает `step` в срезе `[start:stop:step]`?
  
Варианты ответов:
1) Тип списка
2) ❌ Длину списка
3) Индекс начала
4) Шаг выборки элементов
5) Индекс конца
  
### ИИ анализ  
Выбран неверный вариант.  Параметр `step` определяет шаг, с которым выбираются элементы из последовательности.  Например, `step=2` означает выбор каждого второго элемента.  Он может быть положительным (движение слева направо) или отрицательным (движение справа налево, что позволяет развернуть список).  Это не длина списка.  

  
# Вопрос 16. Тема 2: Коллекции уровня «джун+». списки, срезы, вложенные структуры
  
Чем отличается `list.copy()` от `list2 = list1`?
  
Варианты ответов:
1) ✅ `copy()` делает новый список
2) `=` копирует элементы
3) `=` делает глубокую копию
4) Разницы нет
5) `copy()` связывает ссылки
  
### ИИ анализ  
Вы правильно поняли ключевое отличие.  Оператор присваивания `list2 = list1` создаёт новую ссылку (`list2`) на тот же самый объект списка в памяти.  Изменения через одну переменную видны через другую.  Метод `list.copy()` создаёт новый, независимый список-копию с теми же элементами (поверхностная копия).  

  
# Вопрос 17. Тема 2: Коллекции уровня «джун+». списки, срезы, вложенные структуры
  
Как правильно создать список списков без «общей» вложенной ссылки?
  
Варианты ответов:
1) ✅ `a = [[0] * 3 for _ in range(3)]`
2) `a = [[0] * 3] * 3`
3) `a = [0] * 9`
4) `a = (0, 0, 0)`
5) `a = {0: 3}`
  
### ИИ анализ  
Вы выбрали верный способ.  Конструкция `[[0] * 3 for _ in range(3)]` в каждой итерации цикла создаёт новый внутренний список `[0, 0, 0]`.  Вариант `[[0] * 3] * 3` создаёт один внутренний список, а затем три ссылки на него, что приводит к проблеме "общей ссылки": изменение одного внутреннего списка затронет все.  

  
# Вопрос 18. Тема 2: Коллекции уровня «джун+». списки, срезы, вложенные структуры
  
Что такое list comprehension?
  
Варианты ответов:
1) Способ сортировки
2) Тип словаря
3) Способ чтения файла
4) ✅ Короткая запись создания списка
5) Вид цикла while
  
### ИИ анализ  
Точно.  List comprehension (генератор списка) — это компактный и выразительный синтаксис Python для создания нового списка путём применения выражения к каждому элементу итерируемого объекта, с возможностью фильтрации.  Он часто заменяет цикл `for` с `append` и делает код более читаемым и эффективным.  

  
# Вопрос 19. Тема 2: Коллекции уровня «джун+». списки, срезы, вложенные структуры
  
Чем отличается удаление по индексу и удаление по значению в списке?
  
Варианты ответов:
1) По значению удаляют индекс
2) По значению удаляют диапазон
3) По индексу удаляют все совпадения
4) ✅ По индексу удаляют позицию
5) Разницы нет
  
### ИИ анализ  
Вы правильно выделили разницу.  `list.pop(index)` или `del list[index]` удаляют элемент, находящийся на конкретной позиции (индексе).  `list.remove(value)` ищет в списке первый элемент, равный заданному значению, и удаляет его.  Если значения нет, возникает ошибка `ValueError`.  

  
# Вопрос 20. Тема 2: Коллекции уровня «джун+». списки, срезы, вложенные структуры
  
Чем отличается `sort()` от `sorted()`?
  
Варианты ответов:
1) `sorted()` меняет список
2) ✅ `sort()` меняет список на месте
3) Разницы нет
4) `sorted()` работает только с set
5) `sort()` возвращает новый список
  
### ИИ анализ  
Верный ответ.  Метод `list.sort()` изменяет исходный список, упорядочивая его элементы, и возвращает `None`.  Встроенная функция `sorted(iterable)` не изменяет исходную коллекцию, а возвращает новый отсортированный список.  Функция `sorted()` работает с любым итерируемым объектом (списки, кортежи, строки).  

  
# Вопрос 21. Тема 3: Словари и множества. паттерны использования, типичные ошибки
  
Чем отличается `d.get(key)` от `d[key]`, если ключа нет?
  
Варианты ответов:
1) ✅ `get` вернёт None по умолчанию
2) `[]` вернёт None по умолчанию
3) `get` удалит ключ
4) `get` всегда вызывает ошибку
5) Разницы нет
  
### ИИ анализ  
Вы правильно указали поведение по умолчанию.  Обращение `d[key]` вызовет исключение `KeyError`, если ключа `key` нет в словаре.  Метод `d.get(key)` в такой ситуации вернёт `None` (или другое значение, указанное вторым аргументом: `d.get(key, default)`).  Это делает `get` безопасным для случаев, когда отсутствие ключа — ожидаемая ситуация.  

  
# Вопрос 22. Тема 3: Словари и множества. паттерны использования, типичные ошибки
  
Как добавить или обновить значение в словаре по ключу?
  
Варианты ответов:
1) ❌ `d.insert(key)`
2) `d.append(value)`
3) `d.add(k, v)`
4) `d.push(k, v)`
5) `d[key] =