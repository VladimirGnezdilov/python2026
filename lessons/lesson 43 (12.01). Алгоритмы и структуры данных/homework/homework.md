## Домашнее задание: шифр Цезаря (шифрование и расшифровка)

### Цель
Разработать программу, которая умеет **шифровать** и **расшифровывать** текст по методу **Цезаря**: каждая буква заменяется на букву, сдвинутую на фиксированное число позиций в алфавите.

---

## Требования

### 1) Алфавит
Работаем с латиницей:
- `A..Z` и `a..z`

Правила:
- Регистр сохраняется: `A` остается заглавной, `a` остается строчной.
- Символы, которые не являются буквами латиницы (пробелы, цифры, знаки препинания), **не меняются**.
- Сдвиг `shift` может быть любым целым числом (например `3`, `-3`, `29`). Нужно корректно нормализовать сдвиг по длине алфавита.

### 2) Функции
Реализуй две функции:
- `encrypt(text: str, shift: int) -> str`
- `decrypt(text: str, shift: int) -> str`

Требование: `decrypt(encrypt(text, shift), shift) == text` для любых допустимых входных данных.

### 3) Консольный интерфейс
Программа должна уметь работать в консоли.

Минимальный вариант:
- Запросить у пользователя режим: `e` (encrypt) или `d` (decrypt)
- Запросить `shift`
- Запросить `text`
- Вывести результат

---

## Примеры

### Пример 1
Вход:
- режим: `e`
- shift: `3`
- text: `Hello, World!`

Выход:
- `Khoor, Zruog!`

### Пример 2
Вход:
- режим: `d`
- shift: `3`
- text: `Khoor, Zruog!`

Выход:
- `Hello, World!`

### Пример 3 (сдвиг больше длины алфавита)
Вход:
- режим: `e`
- shift: `29`
- text: `abc XYZ`

Выход:
- `def ABC`

---

## Ограничения и подсказки
- Нельзя использовать готовые библиотеки для шифрования. Логику сдвига сделай самостоятельно.
- Можно (и нужно) использовать:
  - `ord()` / `chr()`
  - арифметику по модулю (остаток `%`)
- Постарайся не дублировать код. Обычно шифрование и расшифровка отличаются только знаком сдвига.

---

## Что сдавать
- Один файл: `caesar_cipher.py`
- Внутри:
  - функции `encrypt` и `decrypt`
  - консольная часть (запуск через `python caesar_cipher.py`)

---

## Критерии оценки
- **3/3**: корректно работает encrypt/decrypt, учтены регистр и не-буквенные символы, нормализация сдвига, есть понятный CLI.
- **2/3**: почти все работает, но есть проблемы в краевых случаях (например, `-shift` или `shift > 26`).
- **1/3**: есть попытка реализации, но много ошибок в логике сдвига.
- **0/3**: нет рабочей программы.
