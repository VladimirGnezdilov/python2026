# Домашняя работа: Функции. Параметры, значения по умолчанию, args, kwargs, область видимости

## Задачи

1.  **Функция для форматирования строки с параметрами по умолчанию**
    -   **Описание задачи:** Тренировка объявления функций, использования позиционных и именованных аргументов, а также безопасной работы со значениями по умолчанию для изменяемых типов данных (списков). Задача развивает навык предсказывать результат вызова функции.
    -   **Пример (вход → выход):**
        -   `format_message("Владимир", "отличная работа!")` → `"Владимир, отличная работа!"`
        -   `format_message("Анна", "спасибо", prefix="Уважаемый", suffix="С уважением,")` → `"Уважаемый Анна, спасибо! С уважением,"`
        -   `format_message("Игорь", "напоминание", tags=["важно"])` → `"Игорь, напоминание! Теги: ['важно']"`
        -   `format_message("Ольга", "привет")` (дважды подряд) → Оба раза: `"Ольга, привет!"` (теги не должны накапливаться между вызовами).
    -   **Критерии проверки и ограничения:**
        -   Функция должна называться `format_message`.
        -   Параметры: `name` (обязательный), `text` (обязательный), `prefix` (по умолчанию пустая строка), `suffix` (по умолчанию пустая строка), `tags` (по умолчанию `None`).
        -   Если `tags` не передан (`None`), строка с тегами не добавляется. Если передан список, он должен быть отформатирован в конце сообщения как `" Теги: [список]"`.
        -   Критически важно избежать ловушки с изменяемым значением по умолчанию для параметра `tags`.
        -   Функция должна возвращать отформатированную строку, а не печатать ее.
    -   **Решение (псевдокод):**
        1.  Объяви функцию `format_message` с параметрами `name`, `text`, `prefix` (по умолчанию ""), `suffix` (по умолчанию ""), `tags` (по умолчанию `None`).
        2.  Внутри функции создай пустую строку `result`.
        3.  Если `prefix` не пустой, добавь его и пробел к `result`.
        4.  Добавь к `result` строку в формате `"{name}, {text}!"`.
        5.  Если `suffix` не пустой, добавь к `result` пробел и `suffix`.
        6.  Проверь параметр `tags`: если он не равен `None`, добавь к `result` строку `" Теги: {tags}"`.
        7.  Верни строку `result`.
    -   **Рекомендации:**
        -   Для проверки `tags` используй `is None`, а не `if not tags:`, чтобы не потерять пустой список, переданный явно.
        -   **PEP8:** Имена функций — в `snake_case`. После запятой в параметрах ставится пробел. Максимальная длина строки кода — 79 символов.

2.  **Универсальный калькулятор с `*args` и `**kwargs`**
    -   **Описание задачи:** Закрепление работы с переменным числом аргументов (`*args`) и их распаковкой. Задача учит обрабатывать разные сценарии ввода внутри одной функции и безопасно работать с пустыми наборами данных.
    -   **Пример (вход → выход):**
        -   `calculate("sum", 1, 5, 10)` → `16`
        -   `calculate("mean", 2, 4, 6, 8)` → `5.0`
        -   `calculate("max", 3, 1, 4)` → `4`
        -   `calculate("sum")` или `calculate("mean")` → `0` (обработка случая без чисел).
        -   `calculate("sum", *[10, 20, 30])` → `60` (проверка распаковки).
    -   **Критерии проверки и ограничения:**
        -   Функция должна называться `calculate`.
        -   Первый аргумент — строка `operation` (`"sum"`, `"mean"`, `"max"`).
        -   Остальные аргументы — произвольное количество чисел (целых или с плавающей точкой), передаваемых через `*args`.
        -   Для `"mean"` (среднее) нужно вернуть `float`. Если чисел нет, верни `0`.
        -   Не используй встроенные `sum()`, `max()` в учебных целях для итерации по `args` (хотя в реальности это нормально). Пройдись по `args` циклом.
    -   **Решение (псевдокод):**
        1.  Объяви функцию `calculate` с параметрами `operation` и `*args`.
        2.  Если `args` пуст, верни `0`.
        3.  Используй `if/elif` для проверки `operation`:
            -   Если `"sum"`: создай переменную `total = 0`, пройдись циклом по `args` и прибавь каждое число к `total`. Верни `total`.
            -   Если `"mean"`: посчитай `sum` как в предыдущем пункте, затем раздели `sum` на длину `args`. Верни результат как `float`.
            -   Если `"max"`: создай переменную `current_max` и присвой ей первое число из `args`. Пройдись циклом по остальным числам, обновляя `current_max`, если найдено большее. Верни `current_max`.
        4.  (Опционально) Обработай случай неизвестной операции, вернув `None` или сообщение об ошибке.
    -   **Рекомендации:**
        -   Для итерации по `args` используй цикл `for num in args:`.
        -   **PEP8:** Всегда ставь пробелы вокруг операторов (`=`, `+=`, `/`). После двоеточия в `if/elif` ставь пробел.

3.  **Слияние профилей пользователей с помощью `**kwargs`**
    -   **Описание задачи:** Практика использования `**kwargs` для работы с именованными аргументами и их распаковки. Задача моделирует частую операцию обновления данных (например, в настройках профиля) и учит аккуратно комбинировать словари.
    -   **Пример (вход → выход):**
        -   `update_profile(name="Владимир", level=5)` → `{"name": "Владимир", "level": 5}`
        -   `update_profile(name="Анна", city="Казань", hobby="чтение")` → `{"name": "Анна", "city": "Казань", "hobby": "чтение"}`
        -   Базовый профиль: `base = {"name": "Игорь", "coins": 100}`. Вызов `update_profile(**base, active=True)` → `{"name": "Игорь", "coins": 100, "active": True}`.
        -   Базовый профиль: `base = {"name": "Ольга"}`. Дополнительные данные: `extra = {"city": "Москва", "name": "Оля"}`. Вызов `update_profile(**base, **extra)` → `{"name": "Оля", "city": "Москва"}` (значения из `extra` перезаписывают `base`).
    -   **Критерии проверки и ограничения:**
        -   Функция должна называться `update_profile`.
        -   Она должна принимать произвольные именованные аргументы через `**kwargs` и возвращать словарь, составленный из этих аргументов.
        -   Функция должна корректно обрабатывать распаковку словарей при вызове.
        -   Если переданы несколько значений для одного ключа (как в последнем примере), в итоговом словаре должно остаться последнее переданное значение.
    -   **Решение (псевдокод):**
        1.  Объяви функцию `update_profile` с параметром `**kwargs`.
        2.  Внутри функции создай пустой словарь `profile`.
        3.  (По сути, `kwargs` уже является нужным словарем. Задача — понять, как он формируется). Функция может просто вернуть `kwargs`.
        4.  Протестируй функцию, передавая аргументы напрямую и через распаковку словарей.
    -   **Рекомендации:**
        -   Эта задача демонстрирует, что `**kwargs` внутри функции — это обычный словарь.
        -   **PEP8:** Именованные аргументы в вызове функции также пишутся с пробелом вокруг `=`.

4.  **Управление счетчиком и область видимости**
    -   **Описание задачи:** Освоение концепции области видимости переменных. Задача показывает разницу между изменением глобальной переменной (используя `global`) и предпочтительным способом — возвратом значения. Это помогает избегать скрытых зависимостей в коде.
    -   **Описание задачи:** Создай программу с глобальным счетчиком `total_energy`. Напиши две функции:
        a)  `add_energy_v1(amount)`: которая использует `global` для увеличения `total_energy`.
        b)  `add_energy_v2(current_energy, amount)`: которая принимает текущее значение энергии как аргумент, увеличивает его и возвращает новое значение.
        Протестируй оба подхода.
    -   **Пример (вход → выход):**
        -   Исходно `total_energy = 50`.
        -   Вызов `add_energy_v1(30)`, затем `print(total_energy)` → `80`.
        -   Вызов `new_energy = add_energy_v2(total_energy, 30)`, затем `print(new_energy)` → `80`, `print(total_energy)` → `50` (исходное значение не изменилось).
        -   Чтобы изменить глобальную переменную вторым способом, нужно явно написать `total_energy = add_energy_v2(total_energy, 30)`.
    -   **Критерии проверки и ограничения:**
        -   Объяви глобальную переменную `total_energy = 50` вне функций.
        -   Функция `add_energy_v1` должна использовать ключевое слово `global`.
        -   Функция `add_energy_v2` НЕ должна использовать `global` и должна возвращать результат.
        -   Продемонстрируй вызов обеих функций и вывод значений до и после.
    -   **Решение (псевдокод):**
        1.  В глобальной области видимости создай переменную `total_energy = 50`.
        2.  Объяви функцию `add_energy_v1(amount)`:
            -   Используй `global total_energy`.
            -   Увеличь `total_energy` на `amount`.
        3.  Объяви функцию `add_energy_v2(current_energy, amount)`:
            -   Верни результат выражения `current_energy + amount`.
        4.  В основном коде:
            -   Выведи начальное значение `total_energy`.
            -   Вызови `add_energy_v1(30)` и выведи `total_energy`.
            -   Вызови `add_energy_v2(total_energy, 30)`, сохрани результат в `new_energy` и выведи оба значения: `new_energy` и неизмененное `total_energy`.
            -   Покажи, как изменить `total_energy` "чистым" способом: `total_energy = add_energy_v2(total_energy, 30)`.
    -   **Рекомендации:**
        -   Использование `global` — это особый случай. В большинстве ситуаций лучше использовать подход `add_energy_v2`.
        -   **PEP8:** Глобальные переменные, если они необходимы, пишутся в верхнем регистре с подчеркиваниями (например, `TOTAL_ENERGY`), но для простоты этого упражнения можно оставить `snake_case`. Функции, изменяющие глобальное состояние, должны иметь явные имена.
